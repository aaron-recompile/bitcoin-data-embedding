# Preface

## How People Tried to Push Non-Transaction Data into Bitcoin

### —— A Technical and Reproducible History

从比特币出现的第一天起，人们就不断尝试往链上写入一些本来不是为了交易验证的数据。
文本、图像、指令、资产状态、结构化元数据——这些内容并不属于 UTXO 模型的核心目标，但它们始终以各种方式，被插入输入与输出之间的缝隙。

比特币的共识层只关心两件事：

1. 输入是否满足花费条件（input / witness）
2. 输出是否能被正确锁定（script / scriptPubKey）

除此之外的任何信息，如果能够被嵌入、被解释，那一定不是因为系统为它设计了空间，而是因为某处结构存在可利用的余量。

本书的主题，就是系统地回答一个问题：

"过去十五年里，人们是如何不断利用比特币最原始、最严格的结构，将非交易数据写入系统之中的？"

---

## 两个永恒的载体：input 与 output

无论协议叫什么名字，无论外层标准如何设计，它们的本质都相同：

- 要么写进输入（witness / script path）
  利用见证字段的灵活性承载任意字节。
- 要么写进输出（OP_RETURN / scriptPubKey / Taproot leaf）
  将数据哈希、结构片段或指令嵌入到锁定脚本。

所有"协议"、所有"资产"、所有"NFT"，以及所有"链上状态机"，其存在都依附于这两个基本载体。

---

## 数据显示的两种形态：NFT 与结构化资产

人们写入的数据大体分成两类：

1. **显示型（display-oriented）数据**
   图像、文本、对象，也就是所谓的 NFT。
   它本质是一段能够被外部解释器渲染的内容。

2. **结构型（state-oriented）数据**
   资产余额、所有权、ABI、状态转移指令。
   它们构成一个"链外状态机"，而比特币只存储其最小映射。

从彩色币开始，到 Omni、Counterparty、Stamps、Ordinals、Atomicals，再到 RGB，
这些协议的分歧，不是理念，而是如何利用比特币最小的结构单位，表达自己的状态机。

---

## 为什么要研究它们？

Bitcoin Core 的开发者并非支持这些用法。
很多嵌入方式被视作 policy-level spam，而非协议预期功能。

但从工程角度，这些尝试具有不可替代的价值：

- 它们暴露了比特币结构的真实边界
- 它们展示了脚本、witness、Taproot 的可表达能力
- 它们迫使我们理解 consensus 与 policy 的分界
- 它们是去中心化应用在比特币上的全部可能性与全部限制

本书将用可复现的 testnet 实验、可验证的脚本、原始交易解析、witness dump、以及 Taproot Merkle 构建，
逐一讲解这些协议的原理、优势、脆弱性与工程折衷。

---

## 本书的范式

这不是一部鼓励或反对任何协议的书。
也不是市场分析或投机指南。

这是一本从底层结构出发，用工程方法解剖比特币数据嵌入历史的书。

我们将：

- 系统重建所有历史上的嵌入方式
- 对所有协议进行可复现实验
- 明确 consensus / policy / application 的边界
- 从实际的代码与链上行为中抽象出数据写入模型
- 用真实逻辑解释为什么某些协议存活，而某些必然失败

当你读完本书，你将不仅理解"这些协议是什么"，
你将理解 "它们为什么存在、为什么这么做、为什么这样有效或无效。"

---

## 本书的预期读者

- 比特币脚本与 Taproot 工程师
- Bitcoin Core / Lightning / Wallet 开发者
- 构建下一代链上协议的研究者
- 想从根本理解资产协议与 NFT 设计的人
- 希望掌握"数据如何在比特币中流动"的任何工程师

---

## 结语：比特币不是应用链，但应用不会消失

只要比特币允许你在输入或输出里嵌入数据——
无论是 script、witness、Taproot leaf，还是未来的 covenant——
人们就会继续尝试在其上构建资产、内容与状态机。

这不是偏离比特币，而是探索其边界。

本书试图用可复现的工程，让这些边界第一次被系统描述。
